# eddy_data = {
#     'amplitude': ds.variables['amplitude'][:],
#     'cost_association': ds.variables['cost_association'][:],
#     'effective_area': ds.variables['effective_area'][:],
#     'effective_contour_height': ds.variables['effective_contour_height'][:],
#     'effective_contour_latitude': ds.variables['effective_contour_latitude'][:],
#     'effective_contour_longitude': ds.variables['effective_contour_longitude'][:],
#     'effective_contour_shape_error': ds.variables['effective_contour_shape_error'][:],
#     'effective_radius': ds.variables['effective_radius'][:],
#     'inner_contour_height': ds.variables['inner_contour_height'][:],
#     'latitude': ds.variables['latitude'][:],
#     'latitude_max': ds.variables['latitude_max'][:],
#     'longitude': ds.variables['longitude'][:],
#     'longitude_max': ds.variables['longitude_max'][:],
#     'num_contours': ds.variables['num_contours'][:],
#     'num_point_e': ds.variables['num_point_e'][:],
#     'num_point_s': ds.variables['num_point_s'][:],
#     'observation_flag': ds.variables['observation_flag'][:],
#     'observation_number': ds.variables['observation_number'][:],
#     'speed_area': ds.variables['speed_area'][:],
#     'speed_average': ds.variables['speed_average'][:],
#     'speed_contour_height': ds.variables['speed_contour_height'][:],
#     'speed_contour_latitude': ds.variables['speed_contour_latitude'][:],
#     'speed_contour_longitude': ds.variables['speed_contour_longitude'][:],
#     'speed_contour_shape_error': ds.variables['speed_contour_shape_error'][:],
#     'speed_radius': ds.variables['speed_radius'][:],
#     'date_time': time_data,
#     'track': ds.variables['track'][:],
# }
#
# EddyData.from_netcdf(ds)
#
# # eddy_data = {
# #     'amplitude': ds.variables['amplitude'][:],
# #     'cyclonic_type': ds.variables['cyclonic_type'][:],
# #     'latitude': ds.variables['latitude'][:],
# #     'longitude': ds.variables['longitude'][:],
# #     'observation_flag': ds.variables['observation_flag'][:],
# #     'observation_number': ds.variables['observation_number'][:],
# #     'speed_average': ds.variables['speed_average'][:],
# #     'speed_radius': ds.variables['speed_radius'][:],
# #     'date_time': time_data,
# #     'track': ds.variables['track'][:],
# # }
# ds.close()
from dataclasses import dataclass
from datetime import datetime
from typing import Optional, Any, List

import netCDF4 as nc


@dataclass
class EddyData:
    id: Optional[int]  # BIGSERIAL identity, generated by DB

    amplitude: Optional[int] = None
    cost_association: Optional[float] = None
    effective_area: Optional[float] = None
    effective_contour_height: Optional[float] = None
    effective_contour_latitude: Optional[int] = None
    effective_contour_longitude: Optional[int] = None
    effective_contour_shape_error: Optional[int] = None
    effective_radius: Optional[int] = None
    inner_contour_height: Optional[float] = None

    latitude: Optional[float] = None
    latitude_max: Optional[float] = None
    longitude: Optional[float] = None
    longitude_max: Optional[float] = None

    num_contours: Optional[int] = None
    num_point_e: Optional[int] = None
    num_point_s: Optional[int] = None

    observation_flag: Optional[bool] = None
    observation_number: Optional[int] = None

    speed_area: Optional[float] = None
    speed_average: Optional[int] = None
    speed_contour_height: Optional[float] = None

    # PostGIS inside Python ORM is usually Any / dict / Shapely geometry
    speed_contour_shape: Optional[Any] = None
    speed_contour_shape_error: Optional[int] = None
    speed_radius: Optional[int] = None

    date_time: Optional[datetime] = None
    track: Optional[int] = None
    cyclonic_type: Optional[int] = None

    # Generated column from longitude/latitude; not user-set
    eddy_point: Optional[Any] = None  # geography(Point,4326)

    @classmethod
    def from_dict_of_arrays(cls, data: dict) -> List["EddyData"]:
        """
        Convert a dictionary mapping field names -> numpy arrays
        into a list of EddyData objects (one per index).
        """

        # Determine number of rows (use any array in the dict)
        first_key = next(iter(data))
        n = len(data[first_key])

        results: List[EddyData] = []

        for i in range(n):
            row_kwargs = {key: data[key][i] for key in data}
            results.append(cls(id=None, **row_kwargs))

        return results


# cyclonic_filepath = "data/eddy/META3.2_DT_allsat_Cyclonic_long_19930101_20220209.nc"
filepath = "data/eddy/META3.2_DT_allsat_Anticyclonic_long_19930101_20220209.nc"

ds = nc.Dataset(filepath, 'r')

ds.set_auto_mask(False)
date_time = ds.variables['time']  # Extract dates from the dataset and convert them to standard datetime

time_data = nc.num2date(date_time[:], date_time.units, only_use_cftime_datetimes=False,
                        only_use_python_datetimes=False)
ds.set_auto_maskandscale(False)


eddy_data = EddyData.from_netcdf(ds)

